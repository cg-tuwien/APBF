#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_gpu_shader_int64 : require
#include "cpu_gpu_shared_config.h"

// ---------------- application data ------------------
layout(set = 0, binding = 0) uniform application_data
{
	/** Camera's view matrix */
	mat4 mViewMatrix;
	/** Camera's projection matrix */
	mat4 mProjMatrix;
	/** [0]: time since start, [1]: delta time, [2]: reset particle positions, [3]: set uniform particle radius  */
	vec4 mTimeAndUserInput;
	/** [0]: cullMask for traceRayEXT, [1]: neighborhood-origin particle-id, [2]: perform sphere intersection, [3]: unused  */
	uvec4 mUserInput;
} appData;
// ----------------------------------------------------

// ------------------ particle data -------------------
struct particle {
	vec4 mOriginalPositionRand;
	vec4 mCurrentPositionRadius;
};

layout(set = 1, binding = 0) buffer Particles
{
	particle mParticles[];
} particlesBuffer;
// ----------------------------------------------------

#if BLAS_CENTRIC
// -------------------- aabb data ---------------------
struct aligned_aabb
{
	vec3 mMinBounds;
	vec3 mMaxBounds;
	vec2 _align;
};

layout(set = 1, binding = 1) buffer Aabbs
{
	aligned_aabb mAabbs[];
} aabbsBuffer;
// ----------------------------------------------------
#else
// ----------------- instance data --------------------
struct VkAccelerationStructureInstanceKHR {
    mat3x4          transform;
    int             instanceCustomIndex_and_mask;
    int             instanceShaderBindingTableRecordOffset_and_flags;
    uint64_t        accelerationStructureReference;
};

layout(set = 1, binding = 1) buffer Instances
{
	VkAccelerationStructureInstanceKHR mInstances[];
} geometryInstances;
// ----------------------------------------------------

#endif

// Apply 1-byte mask to the 8 high-bits of an integer, and return the resulting integer
int applyMask(int original, int mask) 
{
	return (original & 0xFFFFFF) | ((mask << 24) & 0xFF000000);
}

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Animate particles:
	const vec3 origPos = particlesBuffer.mParticles[id].mOriginalPositionRand.xyz;
	const float f = particlesBuffer.mParticles[id].mOriginalPositionRand.w;
	const vec3 posOffset = vec3(sin(f * appData.mTimeAndUserInput[0]), cos(f * appData.mTimeAndUserInput[0]), sin(f * appData.mTimeAndUserInput[0]) * cos(f * appData.mTimeAndUserInput[0]));
	const float resetOrNot = 1.0 - appData.mTimeAndUserInput[2];
	vec3 newPosition = origPos + posOffset * resetOrNot;

	const float setUniformRadius = appData.mTimeAndUserInput[3];
	float newRadius = mix(particlesBuffer.mParticles[id].mCurrentPositionRadius.w, float(UNIFORM_PARTICLE_RADIUS), setUniformRadius);

	// Update particles buffer:
	particlesBuffer.mParticles[id].mCurrentPositionRadius.xyz = newPosition;

	// Update AABBs:
	vec3 radiusForAabb = vec3(particlesBuffer.mParticles[id].mCurrentPositionRadius.w);
#if BLAS_CENTRIC
	if (id < aabbsBuffer.mAabbs.length()) {
		aabbsBuffer.mAabbs[id] = aligned_aabb(newPosition - radiusForAabb, newPosition + radiusForAabb, vec2(0,0));
	}
#else 
	if (id < geometryInstances.mInstances.length()) {
		geometryInstances.mInstances[id].transform[0][3] = newPosition.x;
		geometryInstances.mInstances[id].transform[1][3] = newPosition.y;
		geometryInstances.mInstances[id].transform[2][3] = newPosition.z;

		geometryInstances.mInstances[id].transform[0][0] = newRadius * float(RTX_NEIGHBORHOOD_RADIUS_FACTOR);
		geometryInstances.mInstances[id].transform[1][1] = newRadius * float(RTX_NEIGHBORHOOD_RADIUS_FACTOR);
		geometryInstances.mInstances[id].transform[2][2] = newRadius * float(RTX_NEIGHBORHOOD_RADIUS_FACTOR);

		// For each particle, reset its mask:
		geometryInstances.mInstances[id].instanceCustomIndex_and_mask = applyMask(geometryInstances.mInstances[id].instanceCustomIndex_and_mask, NOT_NEIGHBOR_MASK);
	}
#endif
}
