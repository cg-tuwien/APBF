#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_gpu_shader_int64 : require
#include "cpu_gpu_shared_config.h"

// ---------------- application data ------------------
layout(set = 0, binding = 0) uniform application_data
{
	mat4 mViewMatrix;
	mat4 mProjMatrix;
	vec4 mTime;
} appData;
// ----------------------------------------------------

// ------------------ particle data -------------------
struct particle {
	vec4 mOriginalPositionRand;
	vec4 mCurrentPositionRadius;
};

layout(set = 1, binding = 0) buffer Particles
{
	particle mParticles[];
} particlesBuffer;
// ----------------------------------------------------

#if BLAS_CENTRIC
// -------------------- aabb data ---------------------
struct aligned_aabb
{
	vec3 mMinBounds;
	vec3 mMaxBounds;
	vec2 _align;
};

layout(set = 1, binding = 1) buffer Aabbs
{
	aligned_aabb mAabbs[];
} aabbsBuffer;
// ----------------------------------------------------
#else
// ----------------- instance data --------------------
struct VkAccelerationStructureInstanceKHR {
    mat3x4          transform;
    int             instanceCustomIndex_and_mask;
    int             instanceShaderBindingTableRecordOffset_and_flags;
    uint64_t        accelerationStructureReference;
};

layout(set = 1, binding = 1) buffer Instances
{
	VkAccelerationStructureInstanceKHR mInstances[];
} geometryInstances;
// ----------------------------------------------------
#endif

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Animate particles:
	vec3 origPos = particlesBuffer.mParticles[id].mOriginalPositionRand.xyz;
	float f = particlesBuffer.mParticles[id].mOriginalPositionRand.w;
	vec3 posOffset = vec3(sin(f * appData.mTime[0]), cos(f * appData.mTime[0]), 0.0f);
	vec3 newPosition = origPos + posOffset;

	// Update particles buffer:
	particlesBuffer.mParticles[id].mCurrentPositionRadius.xyz = newPosition;

	// Update AABBs:
	vec3 radiusForAabb = vec3(particlesBuffer.mParticles[id].mCurrentPositionRadius.w);
#if BLAS_CENTRIC
	if (id < aabbsBuffer.mAabbs.length()) {
		aabbsBuffer.mAabbs[id] = aligned_aabb(newPosition - radiusForAabb, newPosition + radiusForAabb, vec2(0,0));
	}
#else 
	if (id < geometryInstances.mInstances.length()) {
		geometryInstances.mInstances[id].transform[0][3] = newPosition.x;
		geometryInstances.mInstances[id].transform[1][3] = newPosition.y;
		geometryInstances.mInstances[id].transform[2][3] = newPosition.z;
	}
#endif
}
