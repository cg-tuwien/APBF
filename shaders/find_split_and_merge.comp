#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#include "cpu_gpu_shared_config.h"

#define INV_SELF_GRAD_LENGTH_FACTOR 1.0
#define UNDERPRESSURE_FACTOR 2.0

struct neighbors
{
	uint mNeighbor[NEIGHBOR_LIST_MAX_LENGTH];
};

// ---------------------- lists -----------------------
layout(set = 0, binding = 0)  buffer InIndexList         { uint          inIndexList[]; };
layout(set = 0, binding = 1)  buffer InPosition          { ivec4          inPosition[]; };
layout(set = 0, binding = 2)  buffer InRadius            { float            inRadius[]; };
layout(set = 0, binding = 3)  buffer InBoundariness      { float      inBoundariness[]; };
layout(set = 0, binding = 4)  buffer InBoundaryDist      { float      inBoundaryDist[]; };
layout(set = 0, binding = 5)  buffer OutBoundaryDist     { float     outBoundaryDist[]; };
layout(set = 0, binding = 6)  buffer OutTargetRadius     { float     outTargetRadius[]; };
layout(set = 0, binding = 7)  buffer InNeighbors         { neighbors     inNeighbors[]; };
layout(set = 0, binding = 8)  buffer OutTransferSource   { uint    outTransferSource[]; };
layout(set = 0, binding = 9)  buffer OutTransferTarget   { uint    outTransferTarget[]; };
layout(set = 0, binding = 10) buffer OutTransferTimeLeft { float outTransferTimeLeft[]; };
layout(set = 0, binding = 11) buffer InOutTransferring   { uint    inOutTransferring[]; };
layout(set = 0, binding = 12) buffer OutSplit            { uint             outSplit[]; };
// ----------------------------------------------------

// ------------------- list lengths -------------------
layout(set = 1, binding = 0) buffer InIndexListLength   { uint inIndexListLength; };
layout(set = 1, binding = 1) buffer InOutTransferLength { uint inOutTransferLength; };
layout(set = 1, binding = 2) buffer InOutSplitLength    { uint inOutSplitLength; };
// ----------------------------------------------------

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint id = gl_GlobalInvocationID.x;
	if (id >= inIndexListLength) return;

	uint  idx            = inIndexList[id];
	ivec3 pos            = inPosition[idx].xyz;
	float radius         = inRadius[idx];
	float boundariness   = inBoundariness[id];
	uint  neighborCount  = inNeighbors[id].mNeighbor[0];

	uint  nearestNeighborId;
	float nearestNeighborDist = 1.0 / 0.0; // infinity
	float nearestNeighborRadius;
	bool  nearestNeighborLarger;
	float boundaryDistance = 1.0 / 0.0; // infinity
	
	// compute target radius using boundary distance
	// update boundary distance using boundariness and one iteration of flood fill

	for (uint i = 1; i <= neighborCount; i++) {
		uint  idN           = inNeighbors[id].mNeighbor[i];
		uint  idxN          = inIndexList[idN];
		ivec3 posN          = inPosition[idxN].xyz;
		float radiusN       = inRadius[idxN];
		float boundaryDistN = inBoundaryDist[idN];
		float dist          = length(vec3(posN - pos)) / POS_RESOLUTION;

		boundaryDistance = min(boundaryDistance, boundaryDistN + dist);

		if (idx == idxN) continue;

		if (dist < nearestNeighborDist) {
			nearestNeighborId   = idN;
			nearestNeighborDist = dist;
			nearestNeighborRadius = radiusN;
			nearestNeighborLarger = radiusN > radius || (radiusN == radius && idxN > idx);
		}
	}

	float targetRadius = SMALLEST_TARGET_RADIUS + max(0, (boundaryDistance - TARGET_RADIUS_OFFSET) * TARGET_RADIUS_SCALE_FACTOR);
	outTargetRadius[id] = targetRadius;
	
	outBoundaryDist[id] = (boundaryDistance + radius) * (1 - boundariness);


	// check if particle should merge or split using target radius
	// in case of merge, add directly to the transfers list
	// in case of split, add to outSplit; the particles in this list will later be duplicated and added to the transfers list

//	bool split = targetRadius * (pow(2, 1 / DIMENSIONS) * 0.99) <= radius;
	bool split = false;
	bool merge = nearestNeighborDist < radius && pow(radius, DIMENSIONS) + pow(nearestNeighborRadius, DIMENSIONS) <= pow(targetRadius, DIMENSIONS);
	if (!merge && !split) return;

	uint sourceId = (merge && nearestNeighborLarger) ? nearestNeighborId : id;
	uint targetId = (merge && nearestNeighborLarger) ? id : nearestNeighborId;
	if (atomicExchange(inOutTransferring[sourceId], 1u) == 1u) return;

	if (merge) {
		if (atomicExchange(inOutTransferring[targetId], 1u) == 1u) {
			inOutTransferring[sourceId] = 0u;
			return;
		}
		uint tIdx = atomicAdd(inOutTransferLength, 1u);
		outTransferSource  [tIdx] = sourceId;
		outTransferTarget  [tIdx] = targetId;
		outTransferTimeLeft[tIdx] = MERGE_DURATION;
	} else {
		uint sIdx = atomicAdd(inOutSplitLength, 1u);
		outSplit[sIdx] = id;
	}
}
