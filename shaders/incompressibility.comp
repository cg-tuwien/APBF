#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#include "cpu_gpu_shared_config.h"

#define EPSILON 0.01
#define PI 3.14159265
#define INV_SELF_GRAD_LENGTH_FACTOR 1.0
#define UNDERPRESSURE_FACTOR 2.0

struct neighbors
{
	uint mNeighbor[NEIGHBOR_LIST_MAX_LENGTH];
};

// ---------------------- lists -----------------------
layout(set = 0, binding = 0)  buffer InIndexList         { uint          inIndexList[]; };
layout(set = 0, binding = 1)  buffer InPosition          { ivec4          inPosition[]; };
layout(set = 0, binding = 2)  buffer InRadius            { float            inRadius[]; };
layout(set = 0, binding = 3)  buffer InInverseMass       { float       inInverseMass[]; };
layout(set = 0, binding = 4)  buffer InKernelWidth       { uint        inKernelWidth[]; };
layout(set = 0, binding = 5)  buffer OutKernelWidth      { float      outKernelWidth[]; };
layout(set = 0, binding = 6)  buffer InBoundaryDist      { float      inBoundaryDist[]; };
layout(set = 0, binding = 7)  buffer OutBoundaryDist     { float     outBoundaryDist[]; };
layout(set = 0, binding = 8)  buffer OutTargetRadius     { float     outTargetRadius[]; };
layout(set = 0, binding = 9)  buffer InNeighbors         { neighbors     inNeighbors[]; };
layout(set = 0, binding = 10) buffer OutPosition         { ivec4         outPosition[]; };
layout(set = 0, binding = 11) buffer OutTransferSource   { uint    outTransferSource[]; };
layout(set = 0, binding = 12) buffer OutTransferTarget   { uint    outTransferTarget[]; };
layout(set = 0, binding = 13) buffer OutTransferTimeLeft { float outTransferTimeLeft[]; };
layout(set = 0, binding = 14) buffer InOutTransferring   { uint    inOutTransferring[]; };
// ----------------------------------------------------

// ------------------- list lengths -------------------
layout(set = 1, binding = 0) buffer InIndexListLength   { uint inIndexListLength; };
layout(set = 1, binding = 1) buffer InOutTransferLength { uint inOutTransferLength; };
// ----------------------------------------------------

void add_to_pos(uint particleId, ivec3 posShift)
{
	atomicAdd(outPosition[particleId].x, posShift.x);
	atomicAdd(outPosition[particleId].y, posShift.y);
	atomicAdd(outPosition[particleId].z, posShift.z);
}

float poly6_kernel_height(vec3 r, float h)
{
	float rSquared = dot(r, r);
	float hSquared = h * h;
	if (rSquared > hSquared) return 0.0f;
	return 315.0f * pow(hSquared - rSquared, 3.0f) / (64.0f * PI * pow(h, 9.0f));
}

vec3 spiky_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	return -45.0f * pow(h - dist, 2.0f) / (PI * pow(h, 6.0f)) * (r / dist);
}

float cubic_kernel_height(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h) return 0.0f;
	float q = dist / h;
	float k = 8.0f / (PI * h * h * h);
	if (q <= 0.5f)
	{
		float q2 = q * q;
		float q3 = q * q2;
		return k * (6.0f * q3 - 6.0f * q2 + 1.0f);
	}
	return k * (2.0f * pow(1.0f - q, 3.0f));
}

vec3 cubic_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	float q = dist / h;
	vec3 gradq = r * (1.0f / (dist * h));
	float l = 48.0f / (PI * h * h * h);
	if (q <= 0.5f)
	{
		return l * q * (3.0f * q - 2.0f) * gradq;
	}
	float factor = 1.0f - q;
	return l * (-factor * factor) * gradq;
}

float cone_kernel_height(vec3 r, float h)
{
	float height = 3.0f / (PI * h * h * h);
	return max(0.0f, (1.0f - length(r) / h) * height);
}

vec3 cone_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	return -r / dist;
}

float gauss_kernel_height(vec3 r, float height)
{
	float invDoubleVarianceWithoutPi = pow(height, 2.0f / DIMENSIONS);
	float invDoubleVariance = invDoubleVarianceWithoutPi * PI;
	return exp(-dot(r, r) * invDoubleVariance) * pow(invDoubleVarianceWithoutPi, DIMENSIONS / 2.0f);
}

vec3 gauss_kernel_gradient(vec3 r, float height)
{
	float dist = length(r);
	if (dist < 0.0001f) return vec3(0, 0, 0);
	float invDoubleVariance = pow(height, 2.0f / DIMENSIONS) * PI;
	return -gauss_kernel_height(r, height) * 2.0f * dist * invDoubleVariance * normalize(r);
}

float kernel_height(vec3 r, float aKernelWidth)
{
	switch (KERNEL_ID)
	{
		case 0: return cubic_kernel_height(r, aKernelWidth);
		case 1: return gauss_kernel_height(r, 0.6f / pow(aKernelWidth / 2.0f, DIMENSIONS));
		case 2: return poly6_kernel_height(r, aKernelWidth);
		default: return 0.0f;
	}
}

vec3 kernel_gradient(vec3 r, float aKernelWidth)
{
	switch (KERNEL_ID)
	{
		case 0: return cubic_kernel_gradient(r, aKernelWidth);
		case 1: return gauss_kernel_gradient(r, 0.6f / pow(aKernelWidth / 2.0f, DIMENSIONS));
		case 2: return spiky_kernel_gradient(r, aKernelWidth);
		default: return vec3(0.0f, 0.0f, 0.0f);
	}
}

void update_target_radius_and_transfers(uint id, float boundaryDistance, float radius, float invMass, float selfGradLength, float underpressure, float nearestNeighborDist, uint nearestNeighborId, bool nearestNeighborLarger)
{
	float targetRadius = SMALLEST_TARGET_RADIUS + max(0, (boundaryDistance - TARGET_RADIUS_OFFSET) * TARGET_RADIUS_SCALE_FACTOR);
	
	selfGradLength /= (invMass * INV_SELF_GRAD_LENGTH_FACTOR);
	underpressure = max(0, underpressure) * UNDERPRESSURE_FACTOR;
	float boundariness = pow(min(1, selfGradLength + underpressure), 2);
	outBoundaryDist[id] = (boundaryDistance + radius) * (1 - boundariness);
	outTargetRadius[id] = targetRadius;

	// update transfer list (split & merge)
	bool split = targetRadius * (pow(2, 1 / DIMENSIONS) * 0.99) <= radius;
	bool merge = nearestNeighborDist < radius;
	if (!merge) return; // TODO also enable split

	uint sourceId = (merge && nearestNeighborLarger) ? nearestNeighborId : id;
	uint targetId = (merge && nearestNeighborLarger) ? id : nearestNeighborId;
	if (atomicExchange(inOutTransferring[sourceId], 1u) == 1u) return;
	if (merge) {
		if (atomicExchange(inOutTransferring[targetId], 1u) == 1u) {
			inOutTransferring[sourceId] = 0u;
			return;
		}
		uint tIdx = atomicAdd(inOutTransferLength, 1u);
		outTransferSource  [tIdx] = sourceId;
		outTransferTarget  [tIdx] = targetId;
		outTransferTimeLeft[tIdx] = 4.0f;
	} else {
		// TODO write into split list
	}
}

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint id = gl_GlobalInvocationID.x;
	if (id >= inIndexListLength) return;

	uint  idx            = inIndexList[id];
	ivec3 pos            = inPosition[idx].xyz;
	float radius         = inRadius[idx];
	float invMass        = inInverseMass[idx];
	float kernelWidth    = float(inKernelWidth[id]) / KERNEL_WIDTH_RESOLUTION;
//	float kernelWidth    = radius * KERNEL_SCALE;
	float invRestDensity = pow(2 * radius, DIMENSIONS) * invMass;
	uint  neighborCount  = inNeighbors[id].mNeighbor[0];

	outKernelWidth[id] = kernelWidth;

	float sqrtInvMass[NEIGHBOR_LIST_MAX_LENGTH];
	vec3  weightedGradients[NEIGHBOR_LIST_MAX_LENGTH];
	vec3  weightedGradientsSum = vec3(0, 0, 0);
	uint  neighborSelfIdx;
	uint  nearestNeighborId;
	float nearestNeighborDist = 1.0 / 0.0; // infinity
	bool  nearestNeighborLarger;
	float density = 0;
	float squaredGradSum = 0;
	float boundaryDistance = 1.0 / 0.0; // infinity
	
	// compute weighted gradients, density and the sum of the squared gradients
	for (uint i = 1; i <= neighborCount; i++) {
		uint  idN           = inNeighbors[id].mNeighbor[i];
		uint  idxN          = inIndexList[idN];
		ivec3 posN          = inPosition[idxN].xyz;
		float radiusN       = inRadius[idxN];
		float invMassN      = inInverseMass[idxN];
		float boundaryDistN = inBoundaryDist[idN];
		vec3  diff          = vec3(posN - pos) / POS_RESOLUTION;
		float dist          = length(diff);

		density += kernel_height(diff, kernelWidth) / invMassN;

		sqrtInvMass[i] = sqrt(invMassN);

		// weighted gradient of the current particle itself depends on sum of all other gradients,
		// so wait with its computation until after the for loop.
		if (idx == idxN) {
			neighborSelfIdx = i;
		} else {
			weightedGradients[i] = kernel_gradient(diff, kernelWidth) * invRestDensity / invMassN;
			weightedGradientsSum += weightedGradients[i];

			// scale gradients by inverse mass so that moving lighter particles gets preferred
			weightedGradients[i] *= sqrtInvMass[i];

			squaredGradSum += dot(weightedGradients[i], weightedGradients[i]);

#if ADAPTIVE_SAMPLING
			boundaryDistance = min(boundaryDistance, boundaryDistN + dist);

			if (dist < nearestNeighborDist) {
				nearestNeighborId   = idN;
				nearestNeighborDist = dist;
				nearestNeighborLarger = radiusN > radius || (radiusN == radius && idxN > idx);
			}
#endif
		}
	}
	// now compute the missing weighted gradient - the one for the current particle itself:
	weightedGradients[neighborSelfIdx] = -weightedGradientsSum * sqrt(invMass);
	float selfGradLengthSquared = dot(weightedGradients[neighborSelfIdx], weightedGradients[neighborSelfIdx]);
	squaredGradSum += selfGradLengthSquared;

	float underpressure = 1 - density * invRestDensity;
#if ADAPTIVE_SAMPLING
	update_target_radius_and_transfers(id, boundaryDistance, radius, invMass, sqrt(selfGradLengthSquared), underpressure, nearestNeighborDist, nearestNeighborId, nearestNeighborLarger);
#endif

	float lambda = underpressure / (squaredGradSum + EPSILON);
//	float lambda = max(-0.1, underpressure) / (squaredGradSum + EPSILON);

	// if the density is already lower than the rest density, do nothing
	if (lambda >= 0) return;

	// now we can shift the neighbors so that the density is decreased towards the rest density at the current particle's position:
	for (uint i = 1; i <= neighborCount; i++) {
		uint idN   = inNeighbors[id].mNeighbor[i];
		uint idxN  = inIndexList[idN];
		vec3 shift = weightedGradients[i] * lambda * sqrtInvMass[i];
		add_to_pos(idxN, ivec3(shift * POS_RESOLUTION));
	}
}
