#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable
#include "cpu_gpu_shared_config.h"

#define EPSILON 0.01
#define PI 3.14159265
#define SELF_GRAD_LENGTH_FACTOR 8.0
#define UNDERPRESSURE_FACTOR 2.0
#define BOUNDARINESS_THRESHOLD 0.8

struct neighbors
{
	uint mNeighbor[NEIGHBOR_LIST_MAX_LENGTH];
};

// ---------------------- lists -----------------------
layout(set = 0, binding = 0) buffer InIndexList         { uint          inIndexList[]; };
layout(set = 0, binding = 1) buffer InPosition          { ivec4          inPosition[]; };
layout(set = 0, binding = 2) buffer InRadius            { float            inRadius[]; };
layout(set = 0, binding = 3) buffer InInverseMass       { float       inInverseMass[]; };
layout(set = 0, binding = 4) buffer InKernelWidth       { float       inKernelWidth[]; };
layout(set = 0, binding = 5) buffer InNeighbors         { neighbors     inNeighbors[]; };
layout(set = 0, binding = 6) buffer OutBoundariness     { float     outBoundariness[]; };
layout(set = 0, binding = 7) buffer OutPosition         { ivec4         outPosition[]; };
// ----------------------------------------------------

// ------------------- list lengths -------------------
layout(set = 1, binding = 0) buffer InIndexListLength { uint inIndexListLength; };
// ----------------------------------------------------

// ------------------ apbf settings -------------------
layout(set = 2, binding = 0) uniform ApbfSettings { apbf_settings apbfSettings; };
// ----------------------------------------------------

void add_to_pos(uint particleId, ivec3 posShift)
{
	atomicAdd(outPosition[particleId].x, posShift.x);
	atomicAdd(outPosition[particleId].y, posShift.y);
	atomicAdd(outPosition[particleId].z, posShift.z);
}

float poly6_kernel_height(vec3 r, float h)
{
	float rSquared = dot(r, r);
	float hSquared = h * h;
	if (rSquared > hSquared) return 0.0f;
	return 315.0f * pow(hSquared - rSquared, 3.0f) / (64.0f * PI * pow(h, 9.0f));
}

vec3 spiky_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	return -45.0f * pow(h - dist, 2.0f) / (PI * pow(h, 6.0f)) * (r / dist);
}

float cubic_kernel_height(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h) return 0.0f;
	float q = dist / h;
	float k = 8.0f / (PI * h * h * h);
	if (q <= 0.5f)
	{
		float q2 = q * q;
		float q3 = q * q2;
		return k * (6.0f * q3 - 6.0f * q2 + 1.0f);
	}
	return k * (2.0f * pow(1.0f - q, 3.0f));
}

vec3 cubic_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	float q = dist / h;
	vec3 gradq = r * (1.0f / (dist * h));
	float l = 48.0f / (PI * h * h * h);
	if (q <= 0.5f)
	{
		return l * q * (3.0f * q - 2.0f) * gradq;
	}
	float factor = 1.0f - q;
	return l * (-factor * factor) * gradq;
}

float cone_kernel_height(vec3 r, float h)
{
	float height = 3.0f / (PI * h * h * h);
	return max(0.0f, (1.0f - length(r) / h) * height);
}

vec3 cone_kernel_gradient(vec3 r, float h)
{
	float dist = length(r);
	if (dist > h || dist < 0.0001f) return vec3(0, 0, 0);
	return -r / dist;
}

float gauss_kernel_height(vec3 r, float height)
{
	float invDoubleVarianceWithoutPi = pow(height, 2.0f / DIMENSIONS);
	float invDoubleVariance = invDoubleVarianceWithoutPi * PI;
	return exp(-dot(r, r) * invDoubleVariance) * pow(invDoubleVarianceWithoutPi, DIMENSIONS / 2.0f);
}

vec3 gauss_kernel_gradient(vec3 r, float height)
{
	float dist = length(r);
	if (dist < 0.0001f) return vec3(0, 0, 0);
	float invDoubleVariance = pow(height, 2.0f / DIMENSIONS) * PI;
	return -gauss_kernel_height(r, height) * 2.0f * dist * invDoubleVariance * normalize(r);
}

float kernel_height(vec3 r, float aKernelWidth)
{
	switch (KERNEL_ID)
	{
		case 0: return cubic_kernel_height(r, aKernelWidth);
		case 1: return gauss_kernel_height(r, 0.6f / pow(aKernelWidth / 2.0f, DIMENSIONS));
		case 2: return poly6_kernel_height(r, aKernelWidth);
		default: return 0.0f;
	}
}

vec3 kernel_gradient(vec3 r, float aKernelWidth)
{
	switch (KERNEL_ID)
	{
		case 0: return cubic_kernel_gradient(r, aKernelWidth);
		case 1: return gauss_kernel_gradient(r, 0.6f / pow(aKernelWidth / 2.0f, DIMENSIONS));
		case 2: return spiky_kernel_gradient(r, aKernelWidth);
		default: return vec3(0.0f, 0.0f, 0.0f);
	}
}

void compute_boundariness(uint id, float selfGradLength, float underpressure, vec3 avgDiff)
{
	selfGradLength *= SELF_GRAD_LENGTH_FACTOR;
	underpressure = max(0, underpressure) * UNDERPRESSURE_FACTOR;
	float boundariness = pow(min(1, selfGradLength + underpressure), 2);
//	float oldBoundariness = outBoundariness[id];
//	float targetShift = boundariness - oldBoundariness;
//	float maxStep = mDeltaTime * 5; // TODO
//	float maxStep = 0.005;
//	outBoundariness[id] = oldBoundariness + min(abs(targetShift), maxStep) * sign(targetShift);
	outBoundariness[id] = boundariness;
//	outBoundariness[id] = selfGradLength + underpressure > 1 ? 1 : 0;
//	outBoundariness[id] = length(avgDiff) > BOUNDARINESS_THRESHOLD ? 1 : 0;
}

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint id = gl_GlobalInvocationID.x;
	if (id >= inIndexListLength) return;

	uint  idx            = inIndexList[id];
	ivec3 pos            = inPosition[idx].xyz;
	float radius         = inRadius[idx];
	float invMass        = inInverseMass[idx];
	float kernelWidth    = inKernelWidth[id];
	float invRestDensity = pow(2 * radius, DIMENSIONS) * invMass;
	uint  neighborCount  = inNeighbors[id].mNeighbor[0];

	float sqrtInvMass[NEIGHBOR_LIST_MAX_LENGTH];
	vec3  weightedGradients[NEIGHBOR_LIST_MAX_LENGTH];
	vec3  weightedGradientsSum = vec3(0, 0, 0);
	vec3  avgDiff = vec3(0, 0, 0);
	uint  neighborSelfIdx;
	float density = 0;
	float squaredGradSum = 0;
	float massSum = 0;
	
	// compute weighted gradients, density and the sum of the squared gradients
	for (uint i = 1; i <= neighborCount; i++) {
		uint  idN           = inNeighbors[id].mNeighbor[i];
		uint  idxN          = inIndexList[idN];
		ivec3 posN          = inPosition[idxN].xyz;
		float invMassN      = inInverseMass[idxN];
		float massN         = 1.0 / invMassN;
		vec3  diff          = vec3(posN - pos) / POS_RESOLUTION;

		density += kernel_height(diff, kernelWidth) * massN;

		sqrtInvMass[i] = sqrt(invMassN);
		avgDiff += diff * massN;
		massSum += massN;

		// weighted gradient of the current particle itself depends on sum of all other gradients,
		// so wait with its computation until after the for loop.
		if (idx == idxN) {
			neighborSelfIdx = i;
		} else {
			weightedGradients[i] = kernel_gradient(diff, kernelWidth) * invRestDensity * massN;
			weightedGradientsSum += weightedGradients[i];

			// scale gradients by inverse mass so that moving lighter particles gets preferred
			weightedGradients[i] *= sqrtInvMass[i];

			squaredGradSum += dot(weightedGradients[i], weightedGradients[i]);
		}
	}
	// now compute the missing weighted gradient - the one for the current particle itself:
	weightedGradients[neighborSelfIdx] = -weightedGradientsSum * sqrtInvMass[neighborSelfIdx];
	float selfGradLengthSquared = dot(weightedGradients[neighborSelfIdx], weightedGradients[neighborSelfIdx]);
	squaredGradSum += selfGradLengthSquared;

	float underpressure = 1 - density * invRestDensity;
	if (bool(apbfSettings.mUpdateBoundariness)) {
//		float factor = pow(radius * KERNEL_SCALE / kernelWidth, 2);
		float factor = 1;
		avgDiff /= massSum;
		compute_boundariness(id, factor * sqrt(selfGradLengthSquared) / sqrtInvMass[neighborSelfIdx], underpressure, avgDiff);
	}

	float lambda = underpressure / (squaredGradSum + EPSILON);

	// if the density is already lower than the rest density, do nothing
	if (lambda >= 0) return;

	// now we can shift the neighbors so that the density is decreased towards the rest density at the current particle's position:
	for (uint i = 1; i <= neighborCount; i++) {
		uint idN   = inNeighbors[id].mNeighbor[i];
		uint idxN  = inIndexList[idN];
		vec3 shift = weightedGradients[i] * lambda * sqrtInvMass[i];
		add_to_pos(idxN, ivec3(shift * POS_RESOLUTION));
	}
}
